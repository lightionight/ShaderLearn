#ifndef VERTEXSHOW
#define VERTEXSHOW
uniform float _PointSize = 1.0;
uniform float4 _PointColor = float4(1.0, 0.0, 0.0, 1.0);
uniform float4 _FragColor = float4(0.0, 0.0, 0.0, 0.0);

struct a2v
{
    float4 vertex: POSITION;
    //实例化顶点,分配顶点ID
    UNITY_VERTEX_INPUT_INSTANCE_ID
};
struct v2g
{
    float4 projectionSpacePos : SV_POSITION;
    UNITY_VERTEX_OUTPUT_STEREO
};
struct g2f
{
    float4 projectionSpacePos : SV_POSITION;
    float3 result : TEXCOORD1;
    UNITY_VERTEX_OUTPUT_STEREO
};

v2g vert(a2v v)
{
    v2g o;
    UNITY_SETUP_INSTANCE_ID(v);
    UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
    o.projectionSpacePos = UnityObjectToClipPos(v.vertex);
    return o;
}
[maxvertexcount(1)]
void geom(point v2g i[1], inout PointStream<g2f> pointStream)
{
    float4 r = _PointSize;
    
    g2f o;
    o.projectionSpacePos.xy = i[0].projectionSpacePos.xy;
    o.projectionSpacePos.zw = float2(0.0, 1.0);
    o.result.x = pow((o.projectionSpacePos.x - o.projectionSpacePos.x), 2);
    o.result.y = pow((o.projectionSpacePos.y - o.projectionSpacePos.y), 2);
    o.result.z = pow(r, 2);
    UNITY_TRANSFER_VERTEX_OUTPUT_STEREO(i[0], o);
    pointStream.Append(o);
}
fixed4 frag(g2f o): SV_TARGET
{
    if(o.result.x + o.result.y > o.result.z)
    {
        return fixed4(_FragColor.rgb, 0.0);
    }
    else
    {
        return fixed4(_PointColor.rgb, 1.0);
    }
}
#endif
